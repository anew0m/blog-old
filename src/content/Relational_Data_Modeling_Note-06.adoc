= 관계형 데이터 모델링 노트 6장
정민호
2019-12-12
:jbake-last_updated: 2019-12-12
:jbake-type: post
:jbake-status: published
:jbake-tags: 데이터모델링, 책정리
:description: '데이터모델링 도서인 `관계형 데이터 모델링 노트 개정판` 책의 `6장 이력 데이터 이야기` 요약 및 정리
:jbake-og: {"image": "img/jdk/duke.jpg"}
:idprefix:
:toc:
:sectnums:

---
== 엔터티 이야기
== 정규화 이야기
== 데이터 통합과 서브타입 이야기
== 속성 이야기
== 관계 이야기
== 이력 데이터 이야기
---

.요약
****

. 이력 데이터
.. 이력 데이터 개요
... 이력 데이터(Alterd Data)란?
* 지나간 데이터(Bygone Data). 즉 입력된 데이터가 변경(정정 아님)된 데이터를 이력데이터라고 함
* 이력 데이터는 원천 데이터의 함수 종속이나 파생 종속과 연관됨
* 이력 데이터를 관리하는 이유는 데이터의 과거 상태를 추적할 필요가 있기 때문
* 모델링 시 주요 엔터티는 이력 데이터 요건이 없더라도 생길 것을 대비하는 것이 좋음
* 주 식별자가 아닌 주 식별자에 종속된 속성 값이 바뀌면 이력 데이터가 생기게 됨

... 내역데이터란
* 예전에 쌓인 데이터여도 변경되지 않았다면 이력 데이터가 아니라 내역 데이터
* 과거 데이터라도 본질(원천) 데이터일 수 있음
* 내역 데이터는 살아있는 데이터이며, 내역 성격의 엔터티는 이력 데이터를 같이 관리하지 않아야함

... 이력 엔터티 설계 시점
* 1. 원천 엔터티와 동시에 이력 엔터티를 설계
** 이력 엔터티만을 설계하는 특정 시점이 사실상 없다는 것을 의미
** 따라서 본질(원천) 데이터를 먼저 확고히 해야한 다는 점만 주의하면, 주요 엔터티는 개념 모델링 단계에서 이력 엔터티를 고려(또는 논의)하는 것이 현실적으로 효율적

* 2. 원천 엔터티의 설계가 끝난 시점인 논리 모델링이 끝난 후 또는 물리 모델링 시점에 설계
** 이력 데이터를 논리 모델링이 끝난 물리 모델링 단계에서 설계하면 기존(원천) 엔터티가 영향을 받을 수 있음

* 이력 엔터티 설계 시점은 종합적인 사고가 가능하다는 전제하에서는 한 번에 설계하는게 좋으며, 본질 데이터를 설계할 때 최소한 모델 구조에 대한 변경을 염두에 두고 이력 데이터를 고민해야함
** 중요한 엔터티는 업무 식별자(또는 주 식별자)와 주요 핵심 속성, 이력 데이터 관리 방안, 심각한 성능 이슈 등을 한꺼번에 고민하고 종합적으로 분석 판단해야함
* 그리고 이력 데이터를 설계할 때는 선분이력 방식으로 설계할지를 같이 결정해야하며, 선분이력 시 종료일자 속성이 주 식별자에 포함된다면 그 엔터티에는 하위(자식) 엔터티가 없어야 함





. 이력 엔터티 설계 방법
.. 이력 엔터티 설계 방법 개요
... 엔터티 단위 이력
* 스냅샷 방식으로 저장 공간의 낭비가 심하나, 특정 시점의 전체 속성 값을 조회하는 요건이 많을 때 사용하면 좋음
* 데이터 관리하기가 수월하며, 하위(자식) 엔터티에 미치는 영향도 차단했기 대문에 모델이 안정적인 장점이 있으나, 거의 유사한 스키마의 엔터티를 동일하게 유지해야하는 부담이 존재
* 실무에서 가장 많이 사용하는 방법이며, 원천 엔터티의 하위 엔터티 또는 서브타입이 존재한다면 이 방법을 사용해야 함

... 속성 단위 이력(변경된 속성)
* 변경된 속성의 데이터만 별도로 관리하여 저장 공간이 가장 절약되지만, 과거 특정한 시점에 대해 변경된 속성 값과 변경되지 않은 속성 값을 같이 조회하기 어려움
* 변경 데이터를 별도의 엔터티에서 관리하는 방법과 함께 관리하는 방법으로 나뉠 수 있음

... 속성 그룹 단위 이력(유사)
* 속성 중 내용(도메인)이 유사하거나 같이 사용될 수 있는 속성을 묶어서 별도의 엔터티에서 이력 데이터를 관리하는 방법
* 적절하게 사용할 시 엔터티 단위 이력과 속성 단위 이력의 장점만을 살릴 수 있음




.. 엔터티 단위 이력 설계
... 이력 데이터를 별도의 엔터티에서 관리하는 방법
.... 실체 엔터티
* 실체 엔터티에서는 원천 데이터를 관리하는 엔터티를 변경없이 그대로 존재하며, 이력 데이터는 원천 엔터티와 별도로 이력 엔터티에서 관리함(이력 엔터티의 주식별자에 변경일자 속성 추가)
* 하위(이력) 엔터티가 존재하기 때문에 원천 데이터와 이력 데이터를 한꺼번에 조회하는 요건이 많다면 비효율이 발생
* 비효율을 개선하기 위해 비정규화의 일종인 중복데이터를 사용할 수 있으나, 데이터 중복이 심하게 발생하므로 원칙적으로 사용을 지양해야함

.... 기준 엔터티
* 기준 엔터티이면서 원천 엔터티인 엔터티는 기준일자 속성까지 포함하여 관리
* 데이터는 과거에 입력됐지만 현재도 살아 있는 원천 데이터
* 기준 데이터에 대한 이력(정정 아님) 데이터를 설계할 시 별도의 이력 엔터티 생성 후 관리(이력 엔터티의 주식별자에 변경일자 속성 추가)
* 또는 기준 엔터티에는 현재의 데이터만 관리하고 별도의 이력 엔터티 생성 후 관리(이력 엔터티의 주식별자에 변경일자 속성 추가)

.... 행위 엔터티
* 행위 엔터티에서는 이력을 관리하고자 하는 대상의 엔터티들의 구조를 그대로 이력 엔터티를 생성하여 관리함



... 하나의 엔터티에 원천 데이터와 변경 데이터를 함께 관리하는 방법
* 일반적으로 주요 실체, 행위, 엔터티에는 사용하지 않지만, 기준 엔터티는 하위 엔터티가 존재하지 않고 데이터양도 적어서 이 방법을 사용하기 적절
.... 실체 엔터티
* 이력 데이터를 설계할 때는 먼저 원천 데이터를 설계
* 원천 데이터와 변경 데이터를 함께 관리하기 때문에 엔터티 명에 굳이 '~이력'을 붙이지 않음
* 원천 엔터티에 변경일자 속성 또는 순번 등의 인조식별자를 추가하며, 변경일자 속성에는 변경되지 않았다는 것을 의미하는 값으로 '9999-12-31'을 사용함

.... 기준 엔터티
* 조회하는데 문제가 없다면 굳이 이력 데이터 개념으로 설계할 필요는 없음

.... 행위 엔터티
* 하위(자식) 엔터티가 존재할 때 원천 데이터와 변경 데이터를 함께 관리하는 것은 바람직하지 않음
* __(?) 이해가 잘 안됨__


... 속성 단위로 이력 데이터를 설계하는 방법
* 특정 속성에 대한 이력 엔터티를 생성 후 변경일자 및 변경값 관리
* 중복 데이터가 없어 데이터 저장공간이 절약되지만, 변경되지 않은 속성까지 함께 조회하긴 어려움
* 실무에서 많이 사용되지 않지만, 자주 사용하는 중요한 속성에 대해서는 이 방법의 사용을 고려해야 함


... 원천 데이터를 별도의 엔터티에서 관리하면서, 변경 데이터와 원천 데이터를 함께 관리하는 방법
* 원천 엔터티의 이력을 관리하고자하는 특정 속성을 추출하여 별도의 엔터티에서 데이터를 관리
* 변경 이력 데이터로 설계한 것인지, 발생내역 데이터로 설계한 것인지 구분해야 함



.. 속성 단위 이력 설계
* 역할을 관리하는 별도의 엔터티를 설계할 때 자주 사용됨
* 별도의 엔터티에서 관리하는 이유는 역할은 보통 한 개가 아니라는 사실과 함께 이력 데이터까지 고려하기 때문
* 성능 문제를 해결하기 위해 이력 데이터를 선분이력으로 관리하거나, 또는 비정규화(데이터 중복)하는 방법이 있음


.. 속성 그룹 단위 이력 설계
* 속성 단위 이력 설계하는 방법과 같으며, 다만 성경이 유사한 속성들을 그룹으로 묶어서 관리하는데 차이가 있음
* 유사한 속성들을 그룹으로 묶어서 관리하는 이유는 같이 조회되는 요건을 처리하기 위함
* 따라서 유사한 속성이 아니더라도 같이 사용되는 속성을 그룹으로 묶을 수도 있음
* 적절하게 사용하면 효율적인 모델이 되지만, 명확한 기준 없이 속성을 묶으면 원천 엔터티나 이력 엔터티의 성격이 혼한스러워질 수 있음


.. 종 테이블(Vertical Table)을 이용한 이력 설계
* 변경된 속성을 종 테이블 형식의 별도 엔터티에서 통합 관리하는 것
* 이 방법을 사용할 시 엔터티명과 속성명에 대한 관리 부담이 부가적으로 생기며, 관리할 속성이 명확하지 않고 특정 시점의 모든 속성 데이터를 조회하기 어려움
* 하지만 모델을 형상 관리할 필요가 없다는게 큰 장점으로 실무에서 자주 사용되지만, 지나치게 유연해서 가능하면 사용을 자제하고 종 테이블로 관리할 시 심사숙고하여 결정할 것
* 종 테이블은 유연한 만큼 이력 엔터티를 통합하는데 자유도가 높아 무분별하게 통합할 위험이 있음
* 따라서 성격이 유사하거나, 같은 영역에 있는 몇개의 이력 엔터티를 통합하는게 바람직하고, 조인해서 사용하기 보다는 필요할 때 참고할 용도로 사용하면 효과적임


. 선분이력
.. 선분이력 개요
* 선분이력은 과거 특정 시점의 데이터를 조회하는 요건이 많을 때 사용하는 방법으로 조회성능을 고려한 기법으로, 선분이력이 필요한 경우는 그다지 많지 않으므로 남용 주의
* 특정 데이터가 변경된 시작일자와 변경 전의 종료일자가 이어지도록 인위적으로 데이터를 관리하는 것이 핵심이므로 변경된 릴레이션의 시작과 종료 시점을 연결하면 하나의 선분이 되는 것이 중요
* 넓은 범위의 조회가 있고 성능 문제를 해결해야 한다면 선분이력 방법을 사용해야 하며, 선분이력의 종료일자에 대한 기본 값은 '9999년 12월 31일'이 적당하며, Default 제약을 설정해 사용하는것이 좋음
* 선분이력을 사용할 때 시작일자와 종료일자가 겹치지 않도록 주의
* 선분이력의 종료일자는 추출 속성으로 성능향상을 위해 존재하는 속성이지 본질적인 속성이 아니며, 데이터 성격상 없어도 되는 속성이므로 도입시 성능상 커다란 이득이 있는지도 따져봐야함
* 성능향상을 위해 사용된 만큼 주 식별자에 포함하여 관리하는것이 좋으며, 변경순번과 같이 인조식별자를 사용하는 것은 바람직하지 않음


. 이력 엔터티 설계 절차
* 이력 엔터티를 설계하는 시작점은 이력 데이터를 관리하는 요건이 있느냐 인데, 이력 데이터를 쌓아두지 않더라도 이력 엔터티를 설계해 두는 것은 의미가 있음
* 이력 엔터티는 총 5단계로 아래와 같이 분류 될 수 있음
.. 변경 데이터를 관리해야 하는 요건이 있는지
.. 이력 데이터를 어떤 방법으로 관리해야 가장 효율적인지 분석
.. 선분이력 방법을 채택할지 결정
.. 이력 엔터티의 주 식별자(PK) 확정
.. 다른 엔터티와의 관계를 감안하여 최종적으로 확인


. 서브타입 이력 모델
.. 슈퍼·서브타입 엔터티별로 이력 데이터를 관리하는 방법
* 슈퍼타입 이력 엔터티와 서브타입 이력 엔터티간 참조 무결성 제약이 없기 떄문에 데이터 무결성을 장담할 수 없음
* 특정 시점의 데이터를 조회하기 복잡

.. 슈퍼·서브타입 엔터티와 동일한 구조의 엔터티로 이력 데이터를 관리하는 방법
* 직관적이고 엔터티 간에 참조 무결성 제약이 존재해 데이터 정합성이 맞으며, 조회하기 쉬움
* 성능에 문제가 있을시 선분이력 방법을 적용할 수 있음

.. 속성 단위로 이력 데이터를 관리하는 방법
* 특정 속성을 대상으로 이력을 관리할 때 사용


. 정정 데이터
.. 정정 데이터란
* 정정 데이터는 데이터가 잘못돼 수정한 데이터로써 데이터를 변경한 이력 데이터와는 다름

.. 정정 데이터 관리 방법
* 정정 데이터를 관리하는 방법은 정정이력을 관리하지 않고 데이터 업데이트하는 방법
* 하나의 엔터티에서 변경이력 데이터를 관리하면서, 정정 데이터도 함께 관리하는 방법








****